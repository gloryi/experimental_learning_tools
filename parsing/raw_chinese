是一种广泛使用的解释型、高级和通用的编程语言。支持多种编程范型，包括函数式、指令式、反射式、结构化和面向对象编程。它拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且其本身拥有一个巨大而广泛的标准库。它的语言结构以及面向对象的方法，旨在帮助程序员为小型的和大型的项目编写逻辑清晰的代码。 吉多·范罗苏姆于年代后期开始研发，作为语言的后继者，它也可以被视为采用了叫做-表达式的中缀表示法的一种方言。吉多·范罗苏姆于年首次发布 ..。 .于 年发布并引入了新功能。 .于年发布，它是该语言的主要修订版，并非完全向后兼容。 于年随..版停止支持。 的设计哲学，强调代码的可读性和简洁的语法，尤其是使用空格缩进来划分代码块。相比於或，让开发者能够用更少的代码表达想法。 解释器本身几乎可以在所有的操作系统中运行，它的官方直譯器是用语言编写的。是一個由社群驱动的自由软件，目前由软件基金会管理。是最受欢迎的编程语言之 范羅蘇姆认为語言非常優美和强大，它没有取得成功的原因是不開放造成的，故而将本身設計為可擴充的。並不把所有的特性和功能都集成到語言核心，而是提供了豐富的和工具，以便程式設計師能够輕鬆地使用、、來編寫擴充模組。还可以通过外界函数接口如标准库中的等，来访问动态链接库或共享库中兼容数据类型并调用其中函数，以便于对用其他語言編寫的程式進行集成和封裝。 開發人員盡量避開不成熟或者不重要的優化。一些針對非重要部位的加快運行速度的補丁，通常不會被合併到的官方实现中。在某些對運行速度要求很高的情況，可以使用技术的实现或扩展。 的变量有函数作用域、模块作用域和全局作用域。简单访问（不赋值）一个变量的时候，名字解析服从窄到宽的（局部、包围、全局、内建）顺位规则。在函数中赋值一个变量将导致它成为这个函数的局部变量，就是说它的作用域在整个函数中，而不是在这个赋值之后至这个函数结束，因此在这个赋值之前引用它，不再于这个函数之外查找同名变量而是引发一个错误。缺省的名字解析规则可以用或关键字来覆盖。声明的变量是全局变量。 可以用于嵌套的函数中。嵌套函数中还可以使用声明，用于赋值到给非局部变量。 支持大多数面向对象编程技术。在中所有东西都是对象，包括类、函数、数和模块。它允许多态性，不只是在类层级之内而且通过采用鸭子类型的方式。任何对象可以用于任何类型，只要它有适当的方法和特性（）就能工作。天然支持类的继承包括多重继承，为此采用线性化或方法解析次序（）算法，还支持。支持元类，它是增进类的功能的高级工具。 定義了標準應用接口来協調伺服器與基於的程式之間的溝通。比如，通過模組，可以運行用編寫的程式。是著名的用编写的开源的应用服务器。是用语言写成的非阻塞式服务器，也是轻量级的框架 在位置和关键字形式参数序列末尾可以分别有*或**这样的形式参数，它们对应于在函数调用时提供的，超出形式参数序列规定而无所对应的多个实际参数；在形式参数名字前加一个*号，该形式参数是类型，对应可变数目的位置实际参数；在形式参数名字前加**号，该形式参数是类型，对应可变数目的关键字实际参数。[]在位置实际参数已经在一个序列类型如列表或元组的对象中的情况下，在引用它的变量前加一个*号传递给函数，则其中所有元素解包为多个位置实际参数，关键字实际参数在字典中则加**号来传递给函数。 可以指定形式参数的缺省值，在函数定义时于形式参数序列中以=样式进行一次性初始化。形式参数在初始化之后保持既有绑定，函数的后续调用可继续对它进行访问或变更。[]在函数调用时为有缺省值的形式参数提供实际参数是可选的。支持位置实际参数和关键字实际参数。函数调用时，实际参数可以如同语言那样按照位置与形式参数匹配；也可以采用命名参数（或称为关键字实际参数），即=样式的实际参数。使用不对应实际参数的特殊形式参数/和*，可以将参数序列分为唯位置参数[]、可位置可关键字参数和唯关键字参数三部份。有缺省值的形式参数之后不能跟随无缺省值的可位置形式参数。[]在一个函数调用的实际参数序列中，关键字实际参数必须出现在位置实际参数之后。 在计算机学裡，尾调用是指一个函数里的最后一个动作是返回一个函数的调用结果的情形，即最后一步新调用的返回值直接被当前函数的返回结果。此时，该尾部调用位置被称为尾位置。尾调用中有一种重要而特殊的情形叫做尾递归。经过适当处理，尾递归形式的函数的运行效率可以被极大地优化。尾调用原则上都可以通过简化函数调用栈的结构而获得性能优化（称为“尾调用消除”），但是优化尾调用是否方便可行取决于运行环境对此类优化的支持程度如何。 传统模式的编译器对于尾调用的处理方式就像处理其他普通函数调用一样，总会在调用时创建一个新的栈帧（ ）并将其推入调用栈顶部，用于表示该次函数调用。 当一个函数调用发生时，电脑必须 “记住” 调用函数的位置 —— 返回位置，才可以在调用结束时带着返回值回到该位置，返回位置一般存在调用栈上。在尾调用这种特殊情形中，电脑理论上可以不需要记住尾调用的位置而从被调用的函数直接带着返回值返回调用函数的返回位置（相当于直接连续返回两次）。尾调用消除即是在不改变当前调用栈（也不添加新的返回位置）的情况下跳到新函数的一种优化（完全不改变调用栈是不可能的，还是需要校正调用栈上形式参数与局部变量的信息。） 由于当前函数帧上包含局部变量等等大部分的东西都不需要了，当前的函数帧经过适当的更动以后可以直接当作被尾调用的函数的帧使用，然后程序即可以跳到被尾调用的函数。产生这种函数帧更动代码与 “”（而不是一般常规函数调用的代码）的过程称作尾调用消除  或尾调用优化  , 。尾调用优化让位于尾位置的函数调用跟  语句性能一样高，也因此使得高效的结构编程成为现实。 对函数调用在尾位置的递归或互相递归的函数，由于函数自身调用次数很多，递归层级很深，尾递归优化则使原本  的调用栈空间只需要 。因此一些编程语言的标准要求语言实现进行尾调用消除，例如 與  家族的語言。在  中，語言標準還將尾位置形式化，指定了各種語法中允許尾調用的地方。 以  为例，主要区分普通递归和尾递归对栈空间的使用[需要較佳来源]： 在程序语言实现中，消除尾递归里的尾调用比消除一般的尾调用容易很多。举例来说， 虚拟机（）的实现会消除尾递归里的尾调用（因为重新使用了原来的调用栈），但是不会消除一般的尾调用（因为改变了的调用栈）。 等同样基于  平台的语言可以有效地实现单个函数的尾递归优化，但是对于多个函数的相互尾递归就无法优化了。 则原本不支持尾调用优化，到其第代语言核心标准“ ”开始规定程序引擎应在严格模式下使用尾调用优化。而且 限定了尾位置不含闭包的尾调用才能进行优化。 对所有函数调用使用蹦床，相比常规的调用有着高昂的开销，所以至少有一个编译器即，使用了首先由 听从 未发表建议而描述的一种技术[]。在其中使用常规的调用，但是在每次调用前检查栈的大小。当栈达到它的最大允许大小的时候，在栈上的对象经由算法而被垃圾回收，所有存活数据都将移动到分立的堆之内。随后栈被回缩（弹出），而程序恢复到紧邻垃圾回收之前保存的状态。声称：“的方法通过偶尔的跳下帝国大厦而避免了大量的小型蹦床弹跳”[]。垃圾回收确保了相互尾递归可以无限的继续。但是这种方法要求函数调用都永不返回，因为不能保证它的调用者的栈帧仍然存在；故而它涉及到对程序代码的更加戏剧性的内部重写，即将其改为续体传递风格。 因为在中间过程中重复使用  的函数帧，这种重组节省了空间。这也代表程序员不需要为了担心栈空间或是堆空间用完。在一般的实现中，尾部递归的型态也比其他型态更快速，不过仅仅是常量倍数的差异（非指数差异）。 很多使用函数语言的程序员会为了使用这个优化将递归的代码写成为尾部递归的形式。这通常需要一个多出来代表 “搜集器” 的形参（上述例子的  参数）。在一些语言中的一些函数的实现中（像是过滤一个列的实现等等），如果要使用尾部递归则需要将本来没有副作用的纯函数改写成会更动其他参引的形式[來源請求]。 解释器（英語：），是一种计算机程序，能够把解释型语言解释执行。解释器就像一位「中間人」。解释器边解释边执行，因此依赖于解释器的程序运行速度比较缓慢。解释器的好处是它不需要重新编译整个程序，从而减轻了每次程序更新后编译的负担。相对的编译器一次性将所有源代码编译成二进制文件，执行时无需依赖编译器或其他额外的程序 使用直譯器來執行程式會比直接執行編譯過的機器碼來得慢，但是相對的這個直譯的行為會比編譯再執行來得快。這在程式開發的雛型化階段和只是撰寫試驗性的程式碼時尤其來得重要，因為這個「編輯-直譯-除錯」的循環通常比「編輯-編譯-執行-除錯」的循環來得省時許多。 在直譯器上執行程式比直接執行編譯過的程式碼來得慢，是因為直譯器每次都必須去分析並轉譯它所執行到的程式行，而編譯過的程式就只是直接執行。這個在執行時的分析被稱為"直譯式的成本"。在直譯器中，變數的存取也是比較慢的，因為每次要存取變數的時候它都必須找出該變數實際儲存的位置，而不像編譯過的程式在編譯的時候就決定好了變數的位置了。 在使用直譯器來達到較快的開發速度和使用編譯器來達到較快的執行進度之間是有許多妥協的。有些系統（例如有一些）允許直譯和編譯的程式碼互相呼叫並共享變數。這意味著一旦一個子程式在直譯器中被測試併除錯過之後，它就可以被編譯以獲得較快的執行進度。許多直譯器並不像其名稱所說的那樣執行原始程式碼，反而是把原始程式碼轉換成更壓縮的內部格式。舉例來說，有些的直譯器會把保留字取代成可以用來在转移表中找出相對應指令的單一字节符號。直譯器也可以使用如同編譯器一般的文字分析器和語法分析器然後再轉譯產生出來的抽象語法樹。 直譯式程式相較於編譯式程式有較佳的可攜性，可以容易的在不同軟硬體平台上執行。而編譯式程式經過編譯後的程式則只限定於執行在開發環境平台。 一般而言，用編譯語言寫成的程式，在執行期的執行速度，通常比用直譯語言寫的程式快。因為程式在編譯期，已經被預先編譯成機器碼，可以直接執行，不用像直譯語言一樣，還要多一道直譯程序。 但是要先進行編譯，之後才能執行程式，這也造成了編譯語言的缺點。一般而言，編譯語言的程式開發速度，以及除錯時間，都是比較長的。因為它不像直譯語言可以寫完一行，或一小段程式之後，馬上執行，馬上除錯。直譯語言通常讓程式開發的整體時間變少，在開發過程中，程式師也可以更彈性、快速的測試自己的想法。 為了改善編譯語言的效率而發展出的即時編譯技術，已經縮小了這兩種語言間的差距。這種技術混合了編譯語言與直譯語言的優點，它像編譯語言一樣，先把程式原始碼編譯成字節碼。到執行期時，再將字節碼直譯，之後執行。與是這種技術的代表產物。 早期的计算机软件都是用汇编语言直接编写的，这种状况持续了数年。当人们发现为不同类型的中央处理器（）编写可重用软件的开销要明显高于编写编译器时，人们发明了高级编程语言。由于早期的计算机的内存很少，当大家实现编译器时，遇到了许多技术难题。 大约在世纪年代末期，与机器无关的编程语言被首次提出。随后，人们开发了几种实验性质的编译器。第一个编译器是由美國女性電腦科學家葛麗絲·霍普（  ）于年为- 系統编写的。但是年由任職於的美國電腦科學家约翰·巴科斯（  ）领导的則是第一個被實作出具備完整功能的编译器。年，成为一种较早的能在多种架构下被编译的语言。 高级语言在许多领域流行起来。由于新的编程语言支持的功能越来越多，计算机的架构越来越复杂，这使得编译器也越来越复杂。 早期的编译器是用汇编语言编写的。首个能编译自己源程序的编译器是在年由麻省理工学院的和制作的。从世纪年代起，实现能编译自己源程序的编译器变得越来越可行，不过还是用和语言来实现编译器更加流行。制作某种语言的第一个能编译器，要么需要用其它语言来编写，要么就像和制作编译器那样，用解释器来运行编译器。 增量链接（ ），是针对大型软件的源代码的很小改动就需要花费很长时间全部重新链接问题。特别是程序开发时，不可避免地要不断修改、重新编译、链接、调试程序，链接的耗时大大影响了编程者工作效率。解决办法是：所有函数不再首尾紧挨着存放在内存地址空间，而是在函数之间加上区域作为间隔，为函数添加几句指令稍微变长留有余地。只要函数的代码改动不大，没有超过原所占的空间，链接器只需延长该函数自身，这大大提高了链接的速度。还可以在可执行文件的整个.节末尾设置一个较大的区域，或者使用.节，用来存放修改后变大很多的函数。为了解决由此带来的函数入口地址需要重定位，在.节中增加表（  ），所有的函数调用都是通过间接跳转指令实现，因此函数地址改变仅需要修改表。 在模式下具有动态编译链接功能，也即“  ”功能。一个函数在 中设断点或单步调试，这时该函数在.节中；修改源代码后继续执行该函数， 会重新编译该函数并把它加载到.节中的未利用地址空间（原为的部分），并修改对该函数调用时跳转所用的表条目以及当前寄存器值。 冯·诺伊曼结构又做普林斯顿结构，在一台基于最常见的冯诺依曼体系结构的计算机上，程序从某种外部设备，通常是硬盘，被加载到计算机之內。 如果计算机选择冯诺依曼体系结构，那么程序就被加载入内存。 指令序列顺序执行，直到一条跳转或转移指令被执行，或者一个中断出现。所有这些指令都会改变指令寄存器的内容。 基于这种体系的计算机，如果没有程序的支持，将无法工作。一个计算机程序是一系列指令的集合。 程序裡的指令都是基于机器语言；程序通常首先用一种计算机程序设计语言编写，然后用編譯器或者直譯器翻译成机器语言。 有时，也可以用汇编语言编程，汇编语言实质就是表示机器语言的一组记号－在这种情况下，用于翻译的程序叫做汇编程序。 数据可以被定义为被程序处理的信息。当我们考虑到整个计算机系统时，有时程序和数据的区别就不是那么明显了。中央处理器有时有一组微指令控制硬件，数据可以是一个有待执行的程序（参见脚本编程语言），程序可以编写成去编写其它的程序；所有这些例子都使程序和数据的比较成为一种视角的选择。有人甚至断言程序和数据没有区别。 编写一个程序去生成另外一个程序的过程被称之为元编程（）。它可以被应用于让程序根据给定数据生成代码。单单一个程序可能不足以表示给定数据的所有方面。让一个程序去分析这个数据并生成新的程序去处理数据所有的方面可能会容易一些。就是一例支持这种编程模式的程序语言。 在神经网络裡储存的权重是一种数据。正是这些权重数据，跟网路的拓扑结构一起，定义了网络的行为。人们通常很难界定这些数据到底表示什么或者它们是否可以由程序来代替。这个例子以及跟人工智能相关的其它一些问题进一步考验程序和数据的区别。 编写程序是以下步骤的一个往复过程：编写新的源代码，测试、分析和提高新编写的代码以找出语法和语义错误。从事这种工作的人叫做程序员。由于计算机的飞速发展，编程的要求和种类也日趋多样，由此产生了不同种类的程序设计员，每一种都有更细致的分工和任务。软件工程师和系统分析员就是两个例子。现在，编程的长时间过程被称之为“软件开发”或者软件工程。后者也由于这一学科的日益成熟而逐渐流行。 因此，如今程序设计员可以指某一领域的编程专家，也可以泛指软件公司裡编写一个复杂软件系统里某一块的一般程序员。一组为某一软件公司工作的程序员有时会被指定一个程序组长或者项目经理，用以监督项目进度和完成日期。大型软件通常经历由系统设计师掌握的一个长时间的设计阶段，然后才交付给开发人员。牛仔式的编程（未经详细设计）是不为人所齿的。 两种当今常见的程序开发方式之一是项目组开发方式。使用这种方式项目组里每一个成员都能对项目的进行发表意见，而由其中的某一个人协调不同意见。这样的项目组通常有个左右的成员，这样做是为了便于管理。第二种开发方式是结对开发。 韌體已經演進為一個硬體裝置當中的可程式化的內容，比如說韌體可能包含有一處理器之機械碼或者固定功能之裝置，或是閘道陣列或者可程式化之邏輯裝置之設定。 韌體的一個一般性的特色是它可以隨時以電流清除並重寫 或更換儲存媒介的方式更新。 韌體可以（但並非必需）暴露出一個可由外界連接的介面。比如說在某些數據機的實作中，韌體並非可以直接存取，但卻是由硬體以及韌体所組成回應主機的一部分。 韌體原本被存放在於中，然而價格以及效能的需求已經讓原件供應商妥協於其他的替代方案，包含了非揮發性的媒體比如說以及快閃記憶體或是的解決方案。 快閃記憶體（英語： ），是一种像电可擦写只读存储器一样的存储器，允许對資料進行多次的刪除、加入或改写。這種記憶體廣泛用於記憶卡、隨身碟之中，因其可迅速改寫的特性非常適合手機、筆記本電腦、遊戲主機、掌機之間的檔案轉移，也曾經是數位相機、數位隨身聽和的主要資料轉移方式。 早期的快閃記憶體只要進行一次刪除就會連帶清除掉所有的資料，但目前已可以精確到對指定的資料進行單個刪除。與傳統的硬碟相比，快閃記憶體有更佳的動態抗震性，不會因為劇烈晃動而造成資料丟失；快閃記憶體在被做成記憶卡時非常堅固牢靠，可以浸在水中，也可抵抗高壓力和極端溫度；並且快閃記憶體屬於“非揮發性固態儲存”，非揮發性指的是在保存檔案時不需要消耗電力。基於以上這些優點，使得快閃記憶體非常適用於需要遊歷各種場所並需要隨時存檔的電子設備，因此在小型的可移動電子設備中大放異彩。快閃記憶體的出現迅速取代了造價高昂的普通或需要保持供电才能保存数据的。 快閃記憶體在分類上屬於“”的一種，但一般業界所講的指的是那種“非快閃式”的普通，並不是指它。快閃記憶體以“大區塊抹除”的方式改寫其體內的資料，因為這種大區塊的特性導致它的“写入速度”往往慢于“读取速度”，但也導致它的成本遠遠低於“以位元組為單位寫入”的普通。由於普通需要一個一個位元的刪除已有資料，這讓其傳輸速度極其緩慢，相較之下快閃記體直接使用“大區塊抹除”則會快得多，在會多次用到高清畫面、高品質音樂的情況下尤為明顯。 快閃記憶體又分為與兩型，闪存最常见的封装方式是和，在逻辑接口上的标准则由于厂商阵营而区分为两种：和。手机上的闪存常常以、和（特用于苹果设备中的闪存）的方式存在。 可以通过将标准栅极绝缘来制造。通过绝缘使得其栅极与外界没有电阻连接；然后在浮栅上方沉积多个次级栅极或输入电极，并与其电隔离。由于浮栅完全被高电阻材料包围，输入电极和浮栅之间仅有电容耦合，因此，就其直流工作点而言，浮栅是浮动节点。 在需要修改浮栅电荷量的应用，每个会添加一对额外的小晶体管，以实现注入和隧穿操作。每个晶体管的栅极连接在一起；隧穿晶体管的源极、漏极和体端子相互连接，形成电容隧穿结构。注入晶体管以正常方式连接，并施加特定电压以产生热载流子，然后通过电场将热载流子注入浮栅。 在纯电容应用中，晶体管既可以制造成型，也可以做成型。 对于电荷改变的应用，隧穿晶体管（以及）需要嵌入到阱中，因此该技术决定了可以使用的的类型。 数据（英語：）又稱资料，是通过观测得到的数字性的特征或信息。更专业地说，数据是一组关于一个或多个人或对象的定性或定量变量。数据可以是一堆杂志、一叠报纸、开会记录或者病人的病历记录。 虽然“数据”和“信息”这两个术语经常互相替换使用，但是他们的含义完全不同。在一些流行出版物中，当数据被置于情境之下审视或经过分析之后，“数据”就会变为“信息”；一般而言，数据（）经由处理后称为信息（），从这些信息中分析出来的讯息称为知识（），再通过不断地行动与验证，逐渐形成智慧（）；在大数据（ ）兴起后，数据科学这门学问显得非常重要。 然而在学术课题论述中，数据只是“信息的单元”。在經濟領域上，“信息”衍生信息经济，而“数据”則衍生数据经济。 中心极限定理（英语：  ，簡作 ）是概率论中的一组定理。中心极限定理说明，在适当的条件下，大量相互独立随机变量的均值经适当标准化后依分布收敛于标准正态分布。这组定理是数理统计学和误差分析的理论基础，指出了大量随机变量之和近似服从正态分布的条件。 棣莫弗－拉普拉斯定理指出二项分布的极限为正态分布。高尔顿板可以看作是伯努利试验的实验模型。如果我们把小球碰到钉子看作一次实验，而把从右边落下算是成功，从左边落下看作失败，就有了一次的伯努利试验。小球从顶端到底层共需要经过排钉子，这就相当于一个次伯努利试验。小球的高度曲线也就可以看作二项分布随机变量的概率密度函数。因此，中央极限定理解释了高尔顿板小球累积高度曲线为什么是正态分布独有的钟形曲线。 中心极限定理指出，随着随机变量数量的增加，许多具有有限方差的独立的且相同分布的随机变量的总和将趋于正态分布。 在概率论中，稳定分布（ ，又称为雷维偏阿尔法-稳定分布（  - ））是一种连续概率分布，它是由保罗·皮埃尔·莱维发展起来的。在稳定分布中，独立同分布的随机变量之和及它们本身具有相同的分布。 更明確的說，如果, 為分布之獨立隨機變量，令為, 的线性组合，若之分布滿足，則稱為穩定分布。如果对于所有的和，則稱為严格稳定。 稳定分布被用作金融数据的分析。比如本華·曼德博发现棉花价格的变化服从稳定分布。 另外一个关于稳定分布的重要的性质是它们在中心极限定理中扮演的角色。中心极限定理阐明了随着有限方差的随机变量数量增长，它们的和的分布趋向正态分布。一个推广的理论指出随着服从以递减的幂律尾分布（因此具有无限方差）的随机变量数量增长，它们的和的分布趋向稳定分布 在概率论和统计学中，二项分布（英語： ）是个独立的是/非试验中成功的次数的离散概率分布，其中每次试验的成功概率为。这样的单次成功/失败试验又称为伯努利试验。实际上，当 = 时，二项分布就是伯努利分布。二项分布是显著性差异的二项试验的基础。 是二项式系数（这就是二项分布的名称的由来），又记为, ，，或。该公式可以用以下方法理解：我们希望有次成功和 − 次失败 −  − 。然而，次成功可以在次试验的任何地方出现，而把次成功分布在次试验中共有, 个不同的方法。 在制造二项分布概率的参考表格时，通常表格中只填上/个值。这是因为 > /时的概率可以从它的补集计算
